<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="quguoliang">





<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<link type="text/css" rel="stylesheet" href="//at.alicdn.com/t/font_3061293_3k2vjqu792g.css">
<title>面试题库 | 有点意思</title>



    <link rel="icon" href="/smile.svg">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">有点意思</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/archives">时间轴</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                  <a class="menu-item menu-item-search" title="搜索">
                    搜索
                  </a>
             
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">有点意思</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/archives">时间轴</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>
    <div class="search-form-wrap">
        <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
    </div>
</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部</a>
        <a onclick="go_bottom()">底部</a>
    </div>
    <i id='go-top' class="iconfont icon-huidaodingbu" style="display: none;" onclick="go_top()"></i>
</div>

<script>
    let timer = null;
    let beforeScrollTop = 0
    window.addEventListener('scroll',(e)=>{
        const afterScrollTop = document.documentElement.scrollTop
        if(afterScrollTop>beforeScrollTop && timer){
            clearInterval(timer)
        }
        const topEle = document.getElementById('go-top')
        if(afterScrollTop > 100){
            topEle.style.display='block'
        }else{
            topEle.style.display='none'
        }
        beforeScrollTop=afterScrollTop
    })

    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "收起"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "全部"
    }

    function go_top() {
        timer=setInterval(function(){
            var scrollTop=document.documentElement.scrollTop||document.body.scrollTop;
            var ispeed=Math.floor(-scrollTop/6);
            if(scrollTop==0){
               clearInterval(timer);
            }
            document.documentElement.scrollTop=document.body.scrollTop=scrollTop+ispeed;
        },30)
        // window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">面试题库</h1>
            
                <div class="post-meta">
                    
                        作者: <a itemprop="author" rel="author" href="/">quguoliang</a>
                    

                    
                        <span class="post-time" style="margin:0 15px 0 15px;">
                        日期: <a href="#">2022-01-21 , 星期五&nbsp;&nbsp;17:07:08</a>
                        </span>
                    
                    
                        <span class="post-category">
                    分类:
                            
                                <a href="/categories/%E9%A2%98%E5%BA%93/">题库</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="面试题库"><a href="#面试题库" class="headerlink" title="面试题库"></a>面试题库</h1><h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><h3 id="1、常见状态码"><a href="#1、常见状态码" class="headerlink" title="1、常见状态码"></a>1、常见状态码</h3><ul>
<li>2XX Success(成功状态码)</li>
<li>200 表示从客户端发来的请求在服务器端被正常处理</li>
<li>204 该状态码表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分</li>
<li>206 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求</li>
<li>3XX Redirection(重定向状态码)</li>
<li>301 永久性重定向</li>
<li>302 临时性重定向</li>
<li>4XX Client Error(客户端错误状态码)</li>
<li>400 该状态码表示请求报文中存在语法错误</li>
<li>401 该状态码表示发送的请求需要有通过HTTP认证的认证信息</li>
<li>403 该状态码表明对请求资源的访问被服务器拒绝了。</li>
<li>404 该状态码表明服务器上无法找到请求的资源</li>
<li>5XX Server Error(服务器错误状态码)</li>
<li>500 该状态码表明服务器端在执行请求时发生了错误。</li>
<li>503 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h3 id="2、浏览器缓存策略"><a href="#2、浏览器缓存策略" class="headerlink" title="2、浏览器缓存策略"></a>2、浏览器缓存策略</h3><ul>
<li>强制缓存策略<ul>
<li>Expires</li>
<li>Cache-Control</li>
</ul>
</li>
<li>协商缓存<ul>
<li>启用协商缓存策略的标准是：Cache-control设置为no-cache或者max-age与Expires都过期的情况下</li>
<li>Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高</li>
<li>Last-Modified/ If-Modified-Since<br>Last-Modified是服务器相应请求时，返回该资源文件在服务器最后被修改的时间。<br>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用文件。</li>
<li>Etag / If-None-Match</li>
</ul>
</li>
</ul>
<p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成），如下。<br>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match,则会根据If-None_match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。</p>
<h3 id="3、怎么理解并行加载与串行执行"><a href="#3、怎么理解并行加载与串行执行" class="headerlink" title="3、怎么理解并行加载与串行执行"></a>3、怎么理解并行加载与串行执行</h3><script>运行脚本或加载外部文件时，会阻塞页面渲染，阻塞其他资源的加载。如果页面中需要加载多个js文件，在古老浏览器中性能会比较糟糕。 因此有了最原始的优化原则： 把脚本放在底部。
HTML5 async 非阻塞，加载完后立即执行，不保证顺序；

### 4、从输入url到页面展示的过程中都发生了什么？
* DNS解析
* 发起TCP连接
* 发送HTTP请求
* 服务器处理请求并返回HTTP报文
* 浏览器解析渲染页面
* 连接结束。

拓展 
**1   、回流、重绘**
会导致回流的操作：
* 页面首次渲染
* 浏览器窗口大小发生改变
* 元素尺寸或位置发生改变
* 元素内容变化（文字数量或图片大小等等）
* 元素字体大小变化
* 添加或者删除可见的DOM元素
* 激活CSS伪类（例如：:hover）
* 查询某些属性或调用某些方法

重绘：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

**2、http请求包结构**
一个HTTP请求报文由四个部分组成：请求行、请求头部、空行、请求数据。
* 请求行：由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。
* 请求头：HTTP客户程序(例如浏览器)，向服务器发送请求的时候必须指明请求类型(一般是GET或者 POST)。如有必要，客户程序还可以选择发送其他的请求头。大多数请求头并不是必需的，但Content-Length除外。对于POST请求来说 Content-Length必须出现。
* 空行：它的作用是通过一个空行，告诉服务器请求头部到此为止。
* 请求数据：若方法字段是GET，则此项为空，没有数据，若方法字段是POST,则通常来说此处放置的就是要提交的数据

**CDN原理**
CDN是将源站内容分发至全国所有的节点，从而缩短用户查看对象的延迟，提高用户访问网站的响应速度与网站的可用性的技术。它能够有效解决网络带宽小、用户访问量大、网点分布不均等问题。

### 5、cookies、sessionStorage和localStorage之间区别？


## 一、CSS相关
### 1、margin 塌陷问题？
外边距合并就是，当两个垂直外边距相遇时，它们将形成一个外边距。合并的外边距的高度等于两个发生合并的外边距的高度中的较大者。

几种情况：兄弟关系、父子关系、空元素

解决办法：1、改变其中一个边距到合适距离
            2、BFC

### 2、  两种以上方式实现已知或者未知宽度的垂直水平居中？
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// <span class="number">1</span></span><br><span class="line"><span class="selector-class">.wraper</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: -<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">50px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="number">2</span></span><br><span class="line"><span class="selector-class">.wraper</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="number">3</span></span><br><span class="line"><span class="selector-class">.wraper</span> &#123;</span><br><span class="line">  <span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="number">4</span></span><br><span class="line"><span class="selector-class">.wraper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 3、盒模型

### 4、什么是BFC
一个**块格式化上下文（block formatting context）**是Web页面的可视化CSS渲染的一部分。它是块盒子的布局发生，浮动互相交互的区域。

触发BFC方式：
* body 根元素
* 浮动元素：float 除 none 以外的值
 * 绝对定位元素：position (absolute、fixed)
* display 为 inline-block、table-cells、flex
* overflow 除了 visible 以外的值 (hidden、auto、scroll)


## 二、JS相关
### 说说var、let、const之间的区别
变量提升，暂时性死区

**引述** 闭包

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for(let i =0;i&lt;10;i++)&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123;</span><br><span class="line">	  console.log(i)</span><br><span class="line">	&#125;,100)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">闭包解决</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  (function(i) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


### 1、谈谈__proto__、prototype和constructor之间的关系
（1）__proto__和constructor是对象所独有的，prototype是函数所独有的，由于js函数也是对象，所有函数也有__proto__和constructor。

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> animal();</span><br><span class="line"></span><br><span class="line"><span class="comment">// dog.__proto__ === animal.prototype</span></span><br><span class="line"><span class="comment">// dog.constructor = animal.prototype.constructor</span></span><br></pre></td></tr></table></figure>


### 2、new一个新对象的过程，发生了什么？
(1) 创建一个空对象 son {}
(2) 为 son 准备原型链连接 son.__proto__ = Father.prototype
(3) 重新绑定this，使构造函数的this指向新对象 Father.call(this)
(4) 为新对象属性赋值 son.name
(5) 返回this return this，此时的新对象就拥有了构造函数的方法和属性了

### 3、阐述event loop
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. js主线程它是有一个执行栈的，所有的js代码都会在执行栈里运行</span><br><span class="line"></span><br><span class="line">2. 首先判断是同步任务还是异步任务</span><br><span class="line"></span><br><span class="line">3. 同步任务进入主线程，异步任务(比如setTimeout,ajax,promise.then以及用户点击等操作),异步任务在event table中注册事件，当满足触发条件后（触发条件可能是延时也可能是ajax回调），被推入event queue(任务队列)等待执行。</span><br><span class="line"></span><br><span class="line">4. 而当主线程执行完栈中的所有代码后，它就会检查任务队列是否有任务要执行，如果有任务要执行的话，那么就将该任务放到执行栈中执行。</span><br><span class="line"></span><br><span class="line">5. 如果当前任务队列为空的话，它就会一直循环等待任务到来。</span><br></pre></td></tr></table></figure>

### 4、AST有了解吗？

### 5、js隐式转换
主要规则是：
    对象类型： 对象 -> 字符串 -> 数字
    布尔类型： 布尔 -> 数字
    关系运算符(> 、<、=)等会将数组两边的先进行转换在比较，规则如上，如果两边都是字符串则是比较Unicode值。
[image:E295FF38-976A-4B4B-80F7-12DEC751C38F-21246-0000D56B26CD654C/2791152-ba592aa9b81fe174.png]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(1+true)</span><br><span class="line">console.log(&#x27;abc&#x27;&gt;&#x27;aad&#x27;) </span><br><span class="line">console.log(&#x27;abc&#x27;&gt;&#x27;b&#x27;)</span><br><span class="line">console.log(&#x27;2&#x27;&gt;10)</span><br><span class="line">console.log(&#x27;2&#x27;&gt;&#x27;10&#x27;)</span><br></pre></td></tr></table></figure>

[image:D6D675AF-08BE-4E7B-AD22-BA2A9E5E0987-21246-0000D5E331911B09/1538025444457ed608b84c4.jpg]
[image:5C6AB1E2-D7C3-4A82-B626-BDD9BE8A9EFC-21246-0000D5E63D6FEA7E/1538025524680923d1cd05b.jpg]

### 6、commonJS和ES6模块化的区别
* 语法上面，两者最明显的差异是，CommonJS 模块使用require()和module.exports，ES6 模块使用import和export。


## 三、Vue相关
### 1、 Vue双向绑定原理
原理是数据劫持
核心是Object.defineProperty()

### 2、父子组件生命周期执行顺序

### 3、vue模板编译原理
简单说，Vue的编译过程就是将template转化为render函数的过程。会经历以下阶段
* 生成AST树
* 优化
* codegen
首先解析模版，生成AST语法树(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。
Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。
编译的最后一步是将优化后的AST树转换为可执行的代码。

### 4、Vue 组件通讯有哪几种方式
* Props 和$emit 父组件向子组件传递数据是通过 prop 传递的，子组件传递数据给父组件是通过$emit 触发事件来做到的
* $parent,$children 获取当前组件的父组件和当前组件的子组件
* $attrs 和$listeners A->B->C。Vue 2.4 开始提供了$attrs 和$listeners 来解决这个问题
* 父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用)
* $refs 获取组件实例
* envetBus 兄弟组件数据传递 这种情况下可以使用事件总线的方式
* Vuex 状态管理

### 5、vue异步请求在哪一步发起
可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。

如果异步请求不需要依赖 Dom 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：
* 能更快获取到服务端数据，减少页面 loading 时间；
* ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；

### 6、怎样理解 Vue 的单向数据流
数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。

如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件去修改

### 7、v-for 为什么要加 key
如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速

### 8、你都做过哪些 Vue 的性能优化
* 对象层级不要过深，否则性能就会差
* 不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）
* v-if 和 v-show 区分使用场景
* computed 和 watch 区分使用场景
* v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if
* 大数据列表和表格性能优化-虚拟列表/虚拟表格
* 防止内部泄漏，组件销毁后把全局变量和事件销毁
* 图片懒加载
* 路由懒加载
* 第三方插件的按需引入
* 适当采用 keep-alive 缓存组件
* 防抖、节流运用
* 服务端渲染 SSR or 预渲染

### 9、nextTick 使用场景和原理
nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法

## 四、React相关

### 1、setState 用法和同步‘异步’特性
异步setState：
    1）合成事件（onClick、onChange）中的setState
    2）生命周期函数中的setState
同步setState
    1）原生事件，
    eg：document.body.addEventListener(‘click’, this.changeValue, false)
        document.querySelector().onclick
    2）setTimeout 中
批量更新
    1）会（合并批量更新）：合成事件、钩子函数
    2）不会：原生事件和setTimeout

### 2、Hooks有哪些点需要注意

### 3、react diff原理，与传统diff算法的区别
1. React 通过制定大胆的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题；
2. React 通过**分层求异**的策略，对 tree diff 进行算法优化；
3. React 通过**相同类生成相似树形结构，不同类生成不同树形结构**的策略，对 component diff 进行算法优化；
4. React 通过**设置唯一 key**的策略，对 element diff 进行算法优化；
5. 建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升；
6. 建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。

### 4、为什么不能直接更新state
直接更新state不会导致渲染

### 5、React类组件中为什么要绑定this？（react合成事件）
两个方面，fuction需要绑定this，是因为React是事件处理是合成事件，这里面，事件触发后向上冒泡到document，随后在进行分发到对应子节点处理，这中间会涉及到方法传递临时保存，就会触发js的作用域丢失问题。第二个箭头函数不需要绑定是因为箭头函数会默认帮我们绑定外层作用域，也就是继承当前实例作用域，减少我们手动绑定的操作


### 6、如何避免组件重新渲染？
React 中最常见的问题之一是组件不必要地重新渲染。React 提供了两个方法，在这些情况下非常有用：
* React.memo():这可以防止不必要地重新渲染函数组件
* PureComponent:这可以防止不必要地重新渲染类组件
这两种方法都依赖于对传递给组件的props的浅比较，如果 props 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。
通过使用 **React Profiler**，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。

### 7、useEffect 和useLayoutEffect执行时机
 useEffect 会**在组件渲染到屏幕之后执行**。
useLayoutEffect**会在所有的 DOM 变更之后同步调用** effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。

useEffect 在渲染时是异步执行，并且要等到浏览器将所有变化渲染到屏幕后才会被执行。
useLayoutEffect 在渲染时是同步执行，其执行时机与 componentDidMount，componentDidUpdate 一致，

修改dom操作建议放在useLayoutEffect里面

### 8、了解虚拟Dom吗？

拓展 虚拟Dom为什么能优化性能




## 五、移动端
### 1、1px产生原因及解决办法

**一种是利用 css 中的****transfrom：scaleY(0.5)****，另一种是设置 媒体查询根据不同 DPR 缩放**

### 2、解决iPhone小黑条问题

## 五、编程题
### 1、给定一个字符串，只允许最多删除一个字符，判断其是否可以成为回文字符串？

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">给定：<span class="string">&#x27;abbgba&#x27;</span></span><br><span class="line"></span><br><span class="line">输出：<span class="literal">true</span> </span><br><span class="line"></span><br><span class="line">解析：</span><br><span class="line"><span class="keyword">const</span> isHui = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> l = str.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; l &amp;&amp; str[i] === str[l]) &#123;</span><br><span class="line">    i++;</span><br><span class="line">    l--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isP(i + <span class="number">1</span>, l)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isP(i, l + <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isP</span>(<span class="params">st, ed</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (st &lt; ed) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str[st] !== str[ed]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      st++;</span><br><span class="line">      ed--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

### 2、给定一数组，将其转换为树形结构
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定：</span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">	&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;张一&#x27;</span>, <span class="attr">pid</span>: <span class="number">0</span>&#125;, </span><br><span class="line">	&#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;李二&#x27;</span>, <span class="attr">pid</span>: <span class="number">1</span>&#125;,</span><br><span class="line"> 	&#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;王三&#x27;</span>, <span class="attr">pid</span>: <span class="number">1</span>&#125;, </span><br><span class="line">	&#123;<span class="attr">id</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="string">&#x27;赵四&#x27;</span>, <span class="attr">pid</span>: <span class="number">3</span>&#125;, </span><br><span class="line">	&#123;<span class="attr">id</span>: <span class="number">5</span>, <span class="attr">name</span>: <span class="string">&#x27;钱六&#x27;</span>, <span class="attr">pid</span>: <span class="number">4</span>&#125;</span><br><span class="line"> ]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


### 3、统计字符串中连续出现的最多的字符，以及字符的个数
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">给定：<span class="string">&#x27;aabbaakejsbcccwqaac&#x27;</span></span><br><span class="line"></span><br><span class="line">输出：&#123; <span class="attr">text</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">count</span>: <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line">解析：</span><br><span class="line"><span class="keyword">const</span> getMax = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123; <span class="attr">text</span>: str[<span class="number">0</span>], <span class="attr">count</span>: <span class="number">1</span> &#125;;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str[i] === str[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="keyword">if</span> (!res.text) &#123;</span><br><span class="line">        res = &#123; <span class="attr">text</span>: str[i], count &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (res.count &lt; count) &#123;</span><br><span class="line">        res = &#123; <span class="attr">text</span>: str[i], count &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getMax(<span class="string">&#x27;aabbaakejsbcccwqaac&#x27;</span>)); <span class="comment">// &#123; text: &#x27;c&#x27;, count: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

script start 
async1 start
async2
promise1
promise4
script end
async1 end
promise2
promise5
promise3
setTimeout



        </div>

        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E9%A2%98%E5%BA%93/"># 题库</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">首页</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2022/01/19/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95-leetcode/">前端算法-leetcode</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© quguoliang</span>
    </div>
</footer>

    </div>
    
<script src="/js/search.js"></script>

</body>

</html>